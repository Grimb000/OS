# Коллоквиум 3

**Поведенческие шаблоны проектирования**

Это шаблоны, которые определяют способы взаимодействия между объектами и распределение обязанностей между ними. Они описывают не только структуру классов или объектов, но и схемы их взаимодействия.

Рассмотрим три классических поведенческих шаблона через призму инкапсуляции, принципа «разделяй и властвуй», ортогональных стратегий и влияния многопоточности:

**1. Команда (Command)**

*   **Определение:** Инкапсулирует запрос как объект, позволяя тем самым параметризовать клиенты с разными запросами, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций.
*   **Проблема и Решение:**
    Проблема состоит в необходимости отделить объект, инициирующий операцию (`Invoker`), от объекта, который ее выполняет (`Receiver`), а также реализовать очередь, логирование и отмену/повтор операций.
    Решение заключается в создании интерфейса `Command` с методом `execute()`. Конкретные команды реализуют этот интерфейс, инкапсулируя ссылку на `Receiver` и логику вызова его методов. `Invoker` работает только с объектом `Command` через его метод `execute()`.
*   **Инкапсуляция:** Запрос (действие + параметры + получатель) инкапсулируется в отдельный объект-команду.
*   **Разделяй и властвуй:** Разделяет отправителя запроса (`Invoker`) от получателя (`Receiver`) и самой логики выполнения (`ConcreteCommand`).
*   **Ортогональные стратегии:** `Invoker` работает с абстрактным интерфейсом команды, не завися от конкретной реализации. Команды легко подменять и добавлять.
*   **Многопоточность:**
    Команды могут выполняться асинхронно, например, в пуле потоков. Если команды или `Receiver`-ы работают с общими изменяемыми данными, необходима потокобезопасность (синхронизация). Объекты команд часто делают неизменяемыми (immutable). Если `Receiver` не потокобезопасен, выполнение команд для него нужно синхронизировать.
*   **Примеры:**
    *   **GUI:** Нажатие кнопки (`Invoker`) создает `SaveCommand`, вызывающую `editor.save()`.
    *   **Очередь задач:** Сетевой запрос (`Invoker`) помещает `ProcessOrderCommand` в очередь для выполнения рабочим потоком.
    *   **Undo/Redo:** Действие пользователя инкапсулируется в команду с методами `execute()` и `undo()`.

**2. Стратегия (Strategy)**

*   **Определение:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от клиентов.
*   **Проблема и Решение:**
    Проблема возникает, когда задачу можно решить несколькими способами (алгоритмами), и нужно легко выбирать или менять алгоритм во время выполнения без изменения клиента, избегая множества условных операторов.
    Решение состоит в создании интерфейса `Strategy` с общим методом. Каждый алгоритм реализуется в своем классе `ConcreteStrategy`. `Context` хранит ссылку на `Strategy` и делегирует ей выполнение задачи, позволяя менять стратегию.
*   **Инкапсуляция:** Каждый алгоритм инкапсулирован в свой класс-стратегию.
*   **Разделяй и властвуй:** Отделяет контекст (`Context`) от конкретных реализаций алгоритмов (`ConcreteStrategy`).
*   **Ортогональные стратегии:** `Context` взаимодействует со стратегиями через общий интерфейс. Стратегии можно свободно добавлять или заменять.
*   **Многопоточность:**
    `Context` и стратегии могут использоваться в многопоточной среде. Stateless-стратегии обычно потокобезопасны. Stateful-стратегии или работающие с общими ресурсами требуют синхронизации. Сам `Context` должен быть потокобезопасным, если его стратегия может меняться из разных потоков.
*   **Примеры:**
    *   **Сортировка:** `Collection` использует разные стратегии сортировки (`QuickSortStrategy`, `BubbleSortStrategy`).
    *   **Валидация данных:** `FormValidator` применяет разные стратегии валидации (`EmailValidationStrategy`, `NotEmptyValidationStrategy`).
    *   **Способы оплаты:** `ShoppingCart` позволяет выбрать стратегию оплаты (`CreditCardPaymentStrategy`, `PayPalPaymentStrategy`).

**3. Шаблонный метод (Template Method)**

*   **Определение:** Определяет скелет алгоритма в методе базового класса, оставляя реализацию некоторых шагов на усмотрение подклассов. Позволяет подклассам переопределять шаги, не изменяя структуру алгоритма.
*   **Проблема и Решение:**
    Проблема — наличие нескольких алгоритмов с общей структурой, но разными деталями шагов; необходимость избежать дублирования кода и задать каркас для вариативных частей.
    Решение — создание в абстрактном базовом классе `templateMethod()`, определяющего скелет алгоритма. Он вызывает другие методы (абстрактные или с реализацией по умолчанию/хуки). Подклассы реализуют/переопределяют только вариативные шаги.
*   **Инкапсуляция:** Общая структура алгоритма инкапсулирована в `templateMethod()`. Вариативные части инкапсулированы в переопределяемых методах.
*   **Разделяй и властвуй:** Разделяет инвариантную часть алгоритма (скелет) от вариативных частей (реализация шагов в подклассах).
*   **Ортогональные стратегии:** Меньше связано с выбором независимых стратегий, больше — с настройкой фиксированного процесса с вариативными шагами.
*   **Многопоточность:**
    Сам `templateMethod()` может вызываться из разных потоков. Если шаги алгоритма (в базовом классе или подклассах) обращаются к общим изменяемым данным, необходима синхронизация.
*   **Примеры:**
    *   **Фреймворки:** Жизненный цикл компонента UI (`initialize()`, `render()`, `destroy()`).
    *   **Обработка данных:** Алгоритм "открыть->прочитать->обработать->записать->закрыть" с абстрактным шагом обработки.
    *   **Генерация отчетов:** Скелет "заголовок->данные->форматирование->подвал" с вариативными шагами получения/форматирования данных.

---

**2. Архитектура ПО и влияние многопоточности**

*   **Что такое архитектура ПО?**
    Архитектура программного обеспечения — это фундаментальная организация системы, воплощенная в ее компонентах, их взаимосвязях друг с другом и с окружением, а также принципы, определяющие ее проектирование и развитие. Это набор ключевых проектных решений о высокоуровневой структуре, поведении, взаимодействии элементов и нефункциональных атрибутах (производительность, надежность, масштабируемость).
*   **Влияние многопоточности на Архитектуру:**
    Многопоточность оказывает **существенное влияние** на архитектуру ПО. Необходимость параллельного выполнения требует специфических архитектурных решений.
    *   **Соображения:**
        1.  **Декомпозиция:** Как система разбивается на параллельные компоненты (акторы, микросервисы)?
        2.  **Взаимодействие:** Как компоненты обмениваются данными и синхронизируются (общая память, очереди)?
        3.  **Ресурсы:** Как обеспечивается безопасный доступ к разделяемым ресурсам (БД, файлы)?
        4.  **Масштабируемость:** Как архитектура использует многоядерность и масштабируется под нагрузкой?
        5.  **Надежность:** Как изолируются сбои в потоках?
        6.  **Сложность:** Как минимизировать сложность параллелизма (deadlocks, race conditions)?
        7.  **Паттерны:** Выбор архитектурных паттернов для параллелизма (Producer-Consumer, Thread Pool).

Таким образом, многопоточность — это не просто деталь реализации, а фундаментальный аспект, который должен учитываться при формировании архитектуры ПО.
