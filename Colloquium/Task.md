# Задачи

## Запуск проекта

После клонирования репозитория следуйте этим инструкциям для запуска проекта:

```bash
# Установка зависимостей
npm install

# Запуск всех тестов
npm test

# Запуск примеров
node tests/factorial/factorial.examples.js
node tests/unique-array/unique-array.examples.js
node tests/linked-list/linked-list.examples.js
```

## Описание решения задач

### 1. Генерация первых n факториалов

#### Описание алгоритма:
Факториал числа n (обозначается n!) - это произведение всех положительных целых чисел, меньших или равных n.

```
n! = n × (n-1) × (n-2) × ... × 2 × 1
```

Для особых случаев:
- 0! = 1
- 1! = 1

#### Особенности реализации:
- Использование `BigInt` для работы с большими числами
- Валидация входных данных
- Обработка исключительных ситуаций
- Ограничение на максимальное количество генерируемых факториалов для предотвращения утечки памяти

#### Сложность алгоритма:
- Временная сложность: O(n²) - для генерации n факториалов
- Пространственная сложность: O(n) - для хранения результатов

### 2. Удаление дубликатов из массива

#### Описание алгоритма:
Задача заключается в удалении дубликатов из массива с сохранением исходного порядка элементов. Например, из массива [1, 2, 2, 3, 4, 1, 5] получаем [1, 2, 3, 4, 5].

#### Особенности реализации:
- Использование структуры данных `Set` для оптимального поиска дубликатов
- Специальный метод идентификации для корректного сравнения объектов и массивов
- Обработка различных типов данных (примитивы, объекты, массивы, даты)
- Сохранение исходного порядка элементов
- Возврат нового массива без изменения исходного

#### Сложность алгоритма:
- Временная сложность: O(n) - где n - количество элементов в массиве
- Пространственная сложность: O(n) - для хранения уникальных значений

### 3. Разворот связного списка с использованием рекурсии

#### Описание алгоритма:
Задача - развернуть односвязный список, изменив направление всех ссылок таким образом, чтобы последний элемент стал первым, предпоследний - вторым и т.д. Например, список 1 -> 2 -> 3 -> 4 -> 5 превращается в 5 -> 4 -> 3 -> 2 -> 1.

#### Особенности реализации:
- Рекурсивный подход к развороту списка
- Обработка специальных случаев (пустой список, список с одним элементом)
- Дополнительные методы для удобной работы со списком (создание из массива, преобразование в массив)
- Сохранение целостности данных в каждом узле

#### Сложность алгоритма:
- Временная сложность: O(n) - где n - количество элементов в списке
- Пространственная сложность: O(n) - из-за использования стека рекурсивных вызовов

## Оптимизация и улучшения

### Генерация факториалов
- Для дальнейшей оптимизации можно реализовать кэширование результатов
- Возможна параллельная обработка для больших значений n

### Удаление дубликатов
- Для оптимизации работы с большими массивами можно реализовать потоковую обработку
- Можно добавить опцию для настройки функции сравнения объектов

### Разворот связного списка
- Возможна реализация итеративного варианта для экономии памяти на стеке вызовов
- Можно добавить поддержку двусвязных списков

## Полезные ресурсы

- [MDN Web Docs: JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
- [JavaScript алгоритмы и структуры данных](https://github.com/trekhleb/javascript-algorithms)
- [Jest - JavaScript Testing Framework](https://jestjs.io/)