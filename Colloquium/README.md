# Кислов Илья Романович гр9 ВОПРОСЫ ВАРИАНТ 1 

## 1. Win API, необходимое для решения Лабораторной работы номер 3

## CreateThread - создание нового потока (для потоков marker)

```
  HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  SIZE_T dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID lpParameter,
  DWORD dwCreationFlags,
  LPDWORD lpThreadId
  );
```

## GetExitCodeThread - получение кода завершения потока
```
BOOL GetExitCodeThread(
  HANDLE hThread,
  LPDWORD lpExitCode
);
```
## WaitForSingleObject - ожидание завершения работы потока
```
DWORD WaitForSingleObject(
  HANDLE hHandle,
  DWORD dwMilliseconds
);
```
## CloseHandle - закрытие дескриптора потока
```
BOOL CloseHandle(
  HANDLE hObject
);
```
# Критические секции

## InitializeCriticalSection - инициализация критической секции для защиты массива
```
void InitializeCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```
## EnterCriticalSection - вход в критическую секцию
```
void EnterCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```
## LeaveCriticalSection - выход из критической секции
```
void LeaveCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```
## DeleteCriticalSection - освобождение ресурсов критической секции
```
void DeleteCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```
# События (Events)

## CreateEvent - создание объекта события для сигнализации между потоками
```
HANDLE CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes,
  BOOL bManualReset,
  BOOL bInitialState,
  LPCTSTR lpName
);
```
## SetEvent - установка события в сигнальное состояние
```
BOOL SetEvent(
  HANDLE hEvent
);
```
## ResetEvent - сброс события в несигнальное состояние
```
BOOL ResetEvent(
  HANDLE hEvent
);
```
## WaitForMultipleObjects - ожидание нескольких событий (для ожидания сигналов от всех потоков marker)
```
DWORD WaitForMultipleObjects(
  DWORD nCount,
  const HANDLE *lpHandles,
  BOOL bWaitAll,
  DWORD dwMilliseconds
);
```
# Функции для работы с временем

## Sleep - приостановка выполнения текущего потока
```
void Sleep(
  DWORD dwMilliseconds
);
```
### Другие полезные функции

## srand - инициализация генератора случайных чисел
```
void srand(
  unsigned int seed
);
```
## rand - генерация случайного числа
```
int rand(void);
Функции для работы с консолью
printf или std::cout - вывод информации в консоль
scanf или std::cin - ввод информации с консоли
```
## Пример структуры программы
```
// Определение глобальных переменных и структур
int* array;              // Массив целых чисел
int arraySize;           // Размер массива
int markerCount;         // Количество потоков marker

CRITICAL_SECTION cs;     // Критическая секция для защиты массива
HANDLE* markerThreads;   // Массив дескрипторов потоков marker
HANDLE* continueEvents;  // События для сигнала продолжения работы
HANDLE* impossibleEvents; // События для сигнала о невозможности продолжения
HANDLE* terminateEvents; // События для сигнала завершения работы
```

## 2. Что такое поток в ОС Windows

Поток - объект ядра, которому операционная система выделяет процессорное время для выполнения приложения.

**Основные характеристики потоков в Windows:**
- Каждый поток имеет собственный набор регистров процессора, стек и счетчик команд
- Все потоки одного процесса разделяют между собой адресное пространство, глобальные переменные, дескрипторы ресурсов
- Потоки могут выполняться параллельно на многоядерных системах или псевдопараллельно на одноядерных (за счет переключения контекста)
- Каждый поток имеет свой уникальный идентификатор (Thread ID) в системе
- Потоки могут находиться в различных состояниях: готовность к выполнению, выполнение, ожидание, остановка

**Создание потоков в Windows:**

В Windows API поток создается с помощью функции `CreateThread()`:
```c
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
```

**Преимущества многопоточности:**
- Повышение производительности за счет параллельного выполнения задач
- Более эффективное использование ресурсов системы
- Возможность выполнения фоновых операций без блокировки пользовательского интерфейса
- Улучшение отзывчивости приложений

**Недостатки многопоточности:**
- Увеличение сложности разработки и отладки
- Риск возникновения состояний гонки (race conditions) и взаимных блокировок (deadlocks)
- Дополнительные накладные расходы на управление потоками

## 3. Что такое Мьютекс

Мьютекс - это объект ядра, который обеспечивает решение проблемы взаимного исключения, т. е. одновременного и несинхронизированного доступа нескольких потоков(процессов) к одному участку памяти.

**Основные характеристики мьютекса:**
- Мьютекс всегда находится в одном из двух состояний: захвачен (locked) или свободен (unlocked)
- Только один поток может владеть мьютексом в любой момент времени
- Если поток пытается захватить мьютекс, который уже захвачен другим потоком, он блокируется и ждет освобождения мьютекса
- Мьютекс является именованным объектом ядра Windows, что позволяет использовать его для межпроцессной синхронизации
- Мьютекс сохраняет информацию о том, какой поток его захватил, что помогает предотвращать взаимные блокировки

**Создание и использование мьютекса в Windows API:**
```c
// Создание мьютекса
HANDLE hMutex = CreateMutex(
    NULL,             // атрибуты безопасности (по умолчанию)
    FALSE,            // начальное состояние (не захвачен)
    L"MyMutexName"    // имя мьютекса
);

// Захват мьютекса с ожиданием
WaitForSingleObject(hMutex, INFINITE);

// Защищенный код
// ...

// Освобождение мьютекса
ReleaseMutex(hMutex);

// Закрытие дескриптора мьютекса
CloseHandle(hMutex);
```

**Сценарии использования мьютексов:**
- Защита доступа к разделяемым ресурсам (файлам, базам данных, буферам памяти)
- Синхронизация между потоками разных процессов
- Предотвращение одновременного запуска нескольких экземпляров приложения
- Обеспечение атомарного исполнения критических секций кода

**Отличия мьютекса от критической секции:**

| Характеристика | Мьютекс | Критическая секция |
|----------------|---------|-------------------|
| Область видимости | Между процессами | Только в пределах одного процесса |
| Производительность | Ниже (объект ядра) | Выше (объект пользовательского режима) |
| Именование | Может иметь имя | Не имеет имени |
| Рекурсивность | Рекурсивный | Рекурсивный |

## 4. Что такое Событие (объект синхронизации)

Событием называется оповещение о некотором выполненном действии.

**Типы событий в Windows:**
1. **Событие с ручным сбросом (Manual-reset event)**: после установки в сигнальное состояние остается в нем до явного сброса. Освобождает все ожидающие потоки.
2. **Событие с автоматическим сбросом (Auto-reset event)**: автоматически сбрасывается в несигнальное состояние после освобождения одного ожидающего потока.

**Состояния события:**
- **Сигнальное состояние**: потоки, ожидающие на этом событии, разблокируются
- **Несигнальное состояние**: потоки, ожидающие на этом событии, блокируются до перехода события в сигнальное состояние

**Создание и использование события в Windows API:**
```c
// Создание события с ручным сбросом
HANDLE hEvent = CreateEvent(
    NULL,           // атрибуты безопасности (по умолчанию)
    TRUE,           // тип события: TRUE - ручной сброс, FALSE - автоматический сброс
    FALSE,          // начальное состояние: несигнальное
    L"MyEventName"  // имя события
);

// Ожидание события
WaitForSingleObject(hEvent, INFINITE);

// Установка события в сигнальное состояние
SetEvent(hEvent);

// Сброс события в несигнальное состояние (для события с ручным сбросом)
ResetEvent(hEvent);

// Установка события в сигнальное состояние и последующий сброс
PulseEvent(hEvent);

// Закрытие дескриптора события
CloseHandle(hEvent);
```

**Сценарии использования событий:**
- Сигнализация о завершении задачи или операции
- Реализация модели "производитель-потребитель"
- Синхронизация последовательности действий между потоками
- Управление очередностью доступа к ресурсам
- Реализация таймаутов и прерываний выполнения

**Преимущества событий:**
- Легкость в использовании для простых сценариев синхронизации
- Возможность синхронизации между процессами (через именованные события)
- Эффективность для сценариев "один-ко-многим" (один поток сигнализирует, многие ожидают)
- Возможность ожидания нескольких событий одновременно (с помощью WaitForMultipleObjects)

## 5. Сравнительный анализ стандарта C++ 98 и C++11

###5.1 Многопоточность
В C++98 многопоточность реализуется через WinAPI (CreateThread, WaitForSingleObject, ExitThread), что требует ручного управления дескрипторами (HANDLE) и повышает риск утечек ресурсов. В C++20 используется стандартная библиотека <thread> с классами std::thread и std::jthread, которые автоматически управляют жизненным циклом потоков, исключая необходимость вручную закрывать дескрипторы.

###5.2. Синхронизация
C++98 полагается на WinAPI-механизмы (CRITICAL_SECTION, CreateMutex), где легко допустить ошибку, например, забыв разблокировать мьютекс. В C++20 синхронизация реализуется через RAII-обёртки (std::mutex, std::unique_lock), которые автоматически освобождают ресурсы, а std::condition_variable упрощает координацию потоков без риска deadlock.

###5.3 Работа с памятью и контейнерами
C++98 требует ручного управления памятью (выделение/освобождение через new/delete), что чревато утечками. В C++20 используются умные указатели (std::unique_ptr, std::shared_ptr) и контейнеры STL (std::vector), которые автоматически управляют памятью. Например, в лабораторной работе C++20 динамический массив заменён на std::vector, исключая необходимость ручного удаления.

###5.4 Удобство и безопасность
C++98 вынуждает писать более объёмный и менее безопасный код: например, проверка корректности ввода в цикле требует больше строк. В C++20 лаконичность повышается за счёт алгоритмов STL (std::find) и улучшенного синтаксиса. Также в C++20 появились std::chronoдля удобной работы со временем и std::stop_token (в std::jthread) для безопасной остановки потоков.



 
# ОБЩИЕ ВОПРОСЫ

## 1. Что такое ООП? – полное определение

Объектно-ориентированное программирование (ООП) – это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные в виде полей (также называемых атрибутами или свойствами) и код в виде процедур (также называемых методами). Основными принципами ООП являются:

- **Абстракция** – выделение существенных характеристик объекта, которые отличают его от всех других видов объектов, четко определяя его концептуальные границы.
- **Инкапсуляция** – механизм, объединяющий данные и методы, работающие с этими данными, защищая и то, и другое от внешнего вмешательства и неправильного использования.
- **Наследование** – механизм, позволяющий создавать новые классы на основе существующих, заимствуя их функциональность и добавляя новую.
- **Полиморфизм** – способность объекта принимать разные формы и вести себя по-разному в зависимости от контекста, что позволяет использовать один и тот же интерфейс для разных базовых классов.

ООП также включает такие концепции, как классы, объекты, интерфейсы, делегирование, модульность и множественное наследование, в зависимости от реализации в конкретном языке программирования.

## 2. Магическое число 7 Миллера? – примеры из IT

Магическое число 7 Миллера – это психологическая концепция, предложенная Джорджем Миллером в 1956 году, согласно которой кратковременная память человека может удерживать одновременно примерно 7±2 элементов информации. В IT эта концепция находит следующие применения:

1. **Проектирование пользовательского интерфейса** – оптимальное количество элементов меню или опций должно быть около 7, чтобы пользователи могли легко запомнить и выбрать нужный пункт.

2. **Структура навигации** – рекомендуется не делать более 7 основных разделов на сайте или в приложении для лучшего восприятия пользователями.

3. **Телефонные номера** – традиционно разбиваются на группы по 3-4 цифры, чтобы облегчить запоминание (например, XXX-XXX-XXXX в США).

4. **Количество параметров функций** – хорошей практикой считается ограничение количества параметров функции до 7 или меньше для удобства использования и понимания.

5. **Уровни вложенности** – рекомендуется не превышать 7 уровней вложенности в иерархических структурах данных или организации кода.

6. **Цветовые схемы** – часто ограничиваются 5-9 базовыми цветами в пользовательском интерфейсе для лучшего восприятия и запоминания.

7. **Структура документации** – разделение информации на 5-9 основных разделов для более эффективного усвоения материала.

8. **Количество шагов в процессе** – оптимальное количество шагов в процессе регистрации, оформления заказа или других пользовательских процессах часто ограничивают 5-7 шагами.

## 3. Энтропия ПО – негэнтропийные меры при разработке ПО

Энтропия программного обеспечения – это мера беспорядка, сложности и непредсказуемости в программных системах, которая естественным образом увеличивается со временем. Негэнтропийные меры – это практики, которые помогают уменьшить или контролировать эту энтропию:

1. **Рефакторинг кода** – регулярная переработка существующего кода без изменения его функциональности для улучшения внутренней структуры, что снижает сложность и улучшает понимание.

2. **Стандарты кодирования** – применение единых правил оформления кода, именования переменных и функций, что делает код более последовательным и понятным.

3. **Модульное проектирование** – разделение системы на независимые модули с четкими интерфейсами, что уменьшает связность и сложность.

4. **Автоматическое тестирование** – разработка модульных, интеграционных и регрессионных тестов, которые помогают выявлять и предотвращать деградацию кода.

5. **Документирование кода** – создание и поддержание актуальной документации, которая объясняет архитектуру, дизайн и детали реализации системы.

6. **Непрерывная интеграция/непрерывное развертывание (CI/CD)** – автоматизация процессов сборки, тестирования и выпуска ПО, что обеспечивает стабильность и предсказуемость.

7. **Управление техническим долгом** – систематическое выявление и устранение проблем кода, которые накапливаются со временем.

## 4. 5 признаков сложной системы по Гради Бучу

По Гради Бучу, сложные системы характеризуются следующими признаками:

1. **Иерархическая структура**
   - Пример 1: В моём проекте веб-приложения архитектура включала несколько уровней: презентационный уровень (React-компоненты), уровень бизнес-логики (сервисы), уровень доступа к данным (репозитории) и уровень базы данных (SQL Server).
   - Пример 2: В мобильном приложении, которое я разрабатывал, использовалась иерархия компонентов: контейнеры верхнего уровня → экраны → блоки интерфейса → базовые UI-компоненты.

2. **Относительная примитивность базовых компонентов**
   - Пример 1: В лабораторной работе по ООП я создал базовый класс `Shape` с простыми свойствами (координаты, цвет), от которого наследовались более сложные фигуры (круг, квадрат, многоугольник).
   - Пример 2: В проекте парсера данных я использовал простые атомарные функции для обработки строк, которые затем объединялись в более сложные алгоритмы анализа документов.

3. **Разделение на классы и объекты**
   - Пример 1: В проекте системы управления библиотекой я создал классы `Book`, `User`, `Loan` и т.д., а затем работал с конкретными экземплярами этих классов.
   - Пример 2: В лабораторной работе по моделированию транспортной системы были определены абстрактные классы транспортных средств и маршрутов, на основе которых создавались конкретные объекты (автобус №54, маршрут A→B).

4. **Сильные связи внутри подсистем и слабые между подсистемами**
   - Пример 1: В проекте e-commerce система обработки платежей была сильно связана внутри себя, но взаимодействовала с системой управления заказами только через четко определенный API.
   - Пример 2: В лабораторной работе по разработке игры модуль физики имел сложные внутренние зависимости, но взаимодействовал с модулем рендеринга только через интерфейс `IPhysicsObject`.

5. **Эволюционное развитие**
   - Пример 1: Мой pet-проект менеджера задач начинался с простого приложения для списка дел, но постепенно эволюционировал, добавляя функции категорий, приоритетов, повторяющихся задач и интеграции с календарем.
   - Пример 2: В лабораторной работе по базам данных изначальная схема с 3 таблицами постепенно расширилась до 12 таблиц по мере того, как добавлялись новые требования и функциональность.

## 5. Закон иерархических компенсаций Седова

Закон иерархических компенсаций Седова гласит, что в сложной иерархической системе при повышении уровня организации (увеличении разнообразия, сложности) на верхнем уровне иерархии неизбежно упрощение организации (уменьшение разнообразия) на нижних уровнях, и наоборот. Примеры в эволюции IT сферы:

1. **Высокоуровневые языки программирования и абстракции**: Появление языков программирования высокого уровня (Python, JavaScript) позволило упростить разработку сложных систем, но ценой потери контроля над низкоуровневыми деталями исполнения (управление памятью, оптимизация на уровне инструкций процессора).

2. **Виртуализация и контейнеризация**: Технологии виртуализации (VMware, VirtualBox) и контейнеризации (Docker, Kubernetes) предоставили высокоуровневые инструменты для управления инфраструктурой, но ограничили прямой доступ к аппаратным ресурсам и требуют стандартизации низкоуровневых компонентов.

3. **Фреймворки и библиотеки**: Развитие фреймворков (React, Django, Spring) упростило разработку сложных приложений, но ценой навязывания определенной структуры и ограничения свободы в выборе архитектурных решений на нижних уровнях.

4. **Облачные технологии**: Облачные сервисы (AWS, Azure, Google Cloud) предоставили простые интерфейсы для сложных задач (масштабирование, отказоустойчивость), но потребовали стандартизации низкоуровневых компонентов и ограничили возможности тонкой настройки инфраструктуры.

5. **Абстракции баз данных**: ORM-системы (Hibernate, Entity Framework, SQLAlchemy) упростили работу с базами данных на высоком уровне, но ограничили возможности использования специфических особенностей конкретных СУБД и оптимизации запросов на низком уровне.

6. **Методологии разработки**: Agile-методологии предоставили гибкие инструменты для управления сложными проектами, но потребовали стандартизации и формализации процессов разработки на уровне команд и отдельных разработчиков.
